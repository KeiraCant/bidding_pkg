import rclpy
from rclpy.node import Node
from std_msgs.msg import String
import json
import requests
import math
import numpy as np
from datetime import datetime
import time
import asyncio
import aiohttp
from urllib.parse import quote

class GlobalFirePrioritizationManager(Node):
    def __init__(self):
        super().__init__('global_fire_prioritization_manager')
        
        # Publishers
        self.assignments_pub = self.create_publisher(String, '/assignments', 10)
        self.priority_status_pub = self.create_publisher(String, '/fire_priorities', 10)
        
        # Subscribers
        self.create_subscription(String, '/detected_fires', self.fire_detection_callback, 10)
        self.create_subscription(String, '/task_done', self.task_done_callback, 10)
        
        # Fire and assignment tracking
        self.detected_fires = {}
        self.prioritized_fires = {}
        self.assigned_fires = set()
        self.completed_fires = set()
        
        # Available drones
        self.available_drones = ['drone_1', 'drone_2', 'drone_3']
        self.drone_assignments = {}
        
        # Global simulation area (adjust to your region)
        self.sim_center_lat = 47.6062  # Default: Seattle
        self.sim_center_lon = -122.3321
        
        # Global API Configuration
        self.api_config = {
            # ESA WorldCover - Global 10m land cover (FREE)
            'worldcover_base': 'https://services.terrascope.be/wmts/v2',
            
            # WorldPop - Global population data (FREE)
            'worldpop_base': 'https://api.worldpop.org/v1',
            
            # OpenStreetMap - Global infrastructure (FREE)
            'overpass_base': 'https://overpass-api.de/api/interpreter',
            
            # NASA MODIS - Global vegetation (FREE)
            'modis_base': 'https://modis.gsfc.nasa.gov/data/dataprod',
            
            # OpenWeatherMap - Global weather (FREE with API key)
            'openweather_base': 'https://api.openweathermap.org/data/2.5',
            'openweather_key': 'YOUR_API_KEY_HERE',  # Get free at openweathermap.org
            
            # Global Land Analysis & Discovery (GLAD) - Global land cover
            'glad_base': 'https://glad.earthengine.app/view/global-land-cover-land-use-v1',
            
            # Copernicus Global Land Service (FREE)
            'copernicus_base': 'https://land.copernicus.eu/global/products',
        }
        
        # Priority weights
        self.weights = {
            'population': 0.4,
            'vegetation': 0.3,
            'infrastructure': 0.2,
            'fire_intensity': 0.1
        }
        
        # Global land cover fire risk mapping (ESA WorldCover classes)
        self.worldcover_fire_risk = {
            10: 0.7,   # Tree cover
            20: 0.9,   # Shrubland (HIGH RISK)
            30: 0.8,   # Grassland (HIGH RISK when dry)
            40: 0.5,   # Cropland
            50: 0.2,   # Built-up
            60: 0.3,   # Bare/sparse vegetation
            70: 0.1,   # Snow and ice
            80: 0.0,   # Permanent water bodies
            90: 0.4,   # Herbaceous wetland
            95: 0.6,   # Mangroves
            100: 0.6,  # Moss and lichen
        }
        
        # Global infrastructure priorities
        self.infrastructure_priorities = {
            'hospital': 1.0, 'clinic': 0.9, 'emergency': 1.0,
            'school': 0.8, 'university': 0.8, 'kindergarten': 0.9,
            'fire_station': 0.9, 'police': 0.7,
            'power': 0.9, 'substation': 0.8,
            'water_treatment': 0.8, 'waste_treatment': 0.7,
            'fuel': 0.6, 'industrial': 0.5,
            'residential': 0.6, 'nursing_home': 1.0
        }
        
        # Data caches
        self.population_cache = {}
        self.vegetation_cache = {}
        self.weather_cache = {}
        
        # Timer for assignment processing
        self.create_timer(5.0, self.process_fire_assignments)
        
        self.get_logger().info("üåç Global Fire Prioritization Manager started")

    def fire_detection_callback(self, msg):
        """Receive new fire detections and prioritize them"""
        try:
            data = json.loads(msg.data)
            
            for fire_id, fire_info in data.get('fires', {}).items():
                if fire_id not in self.detected_fires:
                    self.detected_fires[fire_id] = fire_info
                    self.get_logger().info(f"üî• New fire detected: {fire_id}")
                    
                    # Start prioritization process
                    self.prioritize_fire(fire_id, fire_info)
                    
        except Exception as e:
            self.get_logger().error(f"Error processing fire detection: {e}")

    def prioritize_fire(self, fire_id, fire_info):
        """Calculate comprehensive priority score for a fire"""
        location = fire_info['location']
        lat, lon = self.local_to_gps(location[0], location[1])
        
        self.get_logger().info(f"üîç Prioritizing {fire_id} at ({lat:.4f}, {lon:.4f})")
        
        # Create async task for API calls
        asyncio.create_task(self._async_prioritize_fire(fire_id, fire_info, lat, lon))

    async def _async_prioritize_fire(self, fire_id, fire_info, lat, lon):
        """Async version of fire prioritization with global APIs"""
        try:
            # Get priority factors using global APIs
            population_score = await self.get_global_population_risk(lat, lon)
            vegetation_score = await self.get_global_vegetation_risk(lat, lon)
            infrastructure_score = await self.get_global_infrastructure_risk(lat, lon)
            fire_intensity_score = self.get_fire_intensity_score(fire_info)
            weather_modifier = await self.get_global_weather_modifier(lat, lon)
            
            # Apply weather modifier to vegetation risk
            vegetation_score = min(1.0, vegetation_score * weather_modifier)
            
            # Calculate weighted priority score
            priority_score = (
                population_score * self.weights['population'] +
                vegetation_score * self.weights['vegetation'] +
                infrastructure_score * self.weights['infrastructure'] +
                fire_intensity_score * self.weights['fire_intensity']
            ) * 100
            
            # Determine priority level
            if priority_score >= 80:
                priority_level, priority_name = 1, "CRITICAL"
            elif priority_score >= 60:
                priority_level, priority_name = 2, "HIGH"
            elif priority_score >= 40:
                priority_level, priority_name = 3, "MEDIUM"
            elif priority_score >= 20:
                priority_level, priority_name = 4, "LOW"
            else:
                priority_level, priority_name = 5, "VERY_LOW"
            
            priority_data = {
                'fire_id': fire_id,
                'priority_level': priority_level,
                'priority_name': priority_name,
                'priority_score': priority_score,
                'factors': {
                    'population_risk': population_score,
                    'vegetation_risk': vegetation_score,
                    'infrastructure_risk': infrastructure_score,
                    'fire_intensity': fire_intensity_score,
                    'weather_modifier': weather_modifier
                },
                'location': fire_info['location'],
                'gps_coords': [lat, lon],
                'timestamp': datetime.now().isoformat()
            }
            
            self.prioritized_fires[fire_id] = priority_data
            
            self.get_logger().info(
                f"üìä {fire_id} priority: {priority_name} (score: {priority_score:.1f}) - "
                f"Pop: {population_score:.2f}, Veg: {vegetation_score:.2f}, "
                f"Infra: {infrastructure_score:.2f}, Weather: {weather_modifier:.2f}"
            )
            
            self.publish_priority_status()
            
        except Exception as e:
            self.get_logger().error(f"Error in global fire prioritization: {e}")
            self._fallback_prioritize_fire(fire_id, fire_info)

    async def get_global_population_risk(self, lat, lon):
        """Get population density using global APIs"""
        cache_key = f"{lat:.4f},{lon:.4f}"
        
        if cache_key in self.population_cache:
            return self.population_cache[cache_key]
        
        try:
            # Method 1: WorldPop Global
            pop_density = await self.get_worldpop_global(lat, lon)
            
            if pop_density is None:
                # Method 2: OpenStreetMap populated places
                pop_density = await self.get_osm_population_global(lat, lon)
            
            # Convert to risk score
            if pop_density is not None:
                if pop_density > 5000:      # Dense urban
                    risk_score = 1.0
                elif pop_density > 1000:    # Urban
                    risk_score = 0.8
                elif pop_density > 500:     # Suburban
                    risk_score = 0.6
                elif pop_density > 100:     # Town
                    risk_score = 0.4
                elif pop_density > 10:      # Rural populated
                    risk_score = 0.2
                else:                       # Very rural
                    risk_score = 0.1
            else:
                risk_score = 0.3  # Default
            
            self.population_cache[cache_key] = risk_score
            return risk_score
            
        except Exception as e:
            self.get_logger().debug(f"Global population API error: {e}")
            return 0.3

    async def get_worldpop_global(self, lat, lon):
        """Get population from WorldPop global dataset"""
        try:
            # WorldPop provides global coverage
            url = f"{self.api_config['worldpop_base']}/pop/wpgppds"
            params = {
                'lat': lat,
                'lon': lon,
                'year': 2020
            }
            
            async with aiohttp.ClientSession() as session:
                async with session.get(url, params=params, timeout=10) as response:
                    if response.status == 200:
                        data = await response.json()
                        return data.get('data', {}).get('pop_count', None)
            
        except Exception as e:
            self.get_logger().debug(f"WorldPop global error: {e}")
        
        return None

    async def get_osm_population_global(self, lat, lon):
        """Get global population estimate from OpenStreetMap"""
        try:
            overpass_query = f"""
            [out:json][timeout:10];
            (
              node["place"~"^(city|town|village|hamlet|suburb)$"](around:10000,{lat},{lon});
              way["place"~"^(city|town|village|hamlet|suburb)$"](around:10000,{lat},{lon});
              relation["place"~"^(city|town|village|hamlet|suburb)$"](around:10000,{lat},{lon});
            );
            out center;
            """
            
            async with aiohttp.ClientSession() as session:
                async with session.post(
                    self.api_config['overpass_base'],
                    data=overpass_query,
                    timeout=15
                ) as response:
                    if response.status == 200:
                        data = await response.json()
                        
                        total_pop_estimate = 0
                        for element in data.get('elements', []):
                            tags = element.get('tags', {})
                            place_type = tags.get('place', '')
                            population = tags.get('population')
                            
                            # Get population or estimate by place type
                            if population and population.replace(',', '').isdigit():
                                pop_value = int(population.replace(',', ''))
                            else:
                                # Global estimates by place type
                                pop_estimates = {
                                    'city': 100000, 'town': 10000, 'village': 1000,
                                    'hamlet': 200, 'suburb': 5000
                                }
                                pop_value = pop_estimates.get(place_type, 2000)
                            
                            # Calculate distance and weight
                            element_lat = element.get('lat', element.get('center', {}).get('lat'))
                            element_lon = element.get('lon', element.get('center', {}).get('lon'))
                            
                            if element_lat and element_lon:
                                distance = self.haversine_distance(lat, lon, element_lat, element_lon)
                                weight = max(0.1, 1.0 - (distance / 10.0))
                                total_pop_estimate += pop_value * weight
                        
                        # Convert to density estimate
                        return total_pop_estimate / 100  # Normalize
            
        except Exception as e:
            self.get_logger().debug(f"OSM global population error: {e}")
        
        return None

    async def get_global_vegetation_risk(self, lat, lon):
        """Get vegetation risk using global land cover data"""
        cache_key = f"{lat:.4f},{lon:.4f}"
        
        if cache_key in self.vegetation_cache:
            return self.vegetation_cache[cache_key]
        
        try:
            # Method 1: ESA WorldCover (global 10m resolution)
            land_cover = await self.get_esa_worldcover(lat, lon)
            
            if land_cover:
                base_risk = self.worldcover_fire_risk.get(land_cover, 0.5)
            else:
                # Method 2: OSM land use fallback
                base_risk = await self.get_osm_land_use_risk(lat, lon)
            
            self.vegetation_cache[cache_key] = base_risk
            return base_risk
            
        except Exception as e:
            self.get_logger().debug(f"Global vegetation error: {e}")
            return 0.5

    async def get_esa_worldcover(self, lat, lon):
        """Get land cover from ESA WorldCover global dataset"""
        try:
            # ESA WorldCover provides global 10m land cover data
            # This is a simplified example - actual implementation would use
            # WMS/WMTS services or Google Earth Engine
            
            # For now, use OSM as proxy
            return await self.get_osm_land_cover_proxy(lat, lon)
            
        except Exception as e:
            self.get_logger().debug(f"ESA WorldCover error: {e}")
            return None

    async def get_osm_land_cover_proxy(self, lat, lon):
        """Use OSM data as proxy for global land cover"""
        try:
            overpass_query = f"""
            [out:json][timeout:10];
            (
              way["natural"](around:2000,{lat},{lon});
              way["landuse"](around:2000,{lat},{lon});
              relation["natural"](around:2000,{lat},{lon});
              relation["landuse"](around:2000,{lat},{lon});
            );
            out center;
            """
            
            async with aiohttp.ClientSession() as session:
                async with session.post(
                    self.api_config['overpass_base'],
                    data=overpass_query,
                    timeout=15
                ) as response:
                    if response.status == 200:
                        data = await response.json()
                        
                        # Map OSM tags to WorldCover classes
                        osm_to_worldcover = {
                            'forest': 10, 'wood': 10,           # Tree cover
                            'scrub': 20, 'heath': 20,           # Shrubland
                            'grassland': 30, 'meadow': 30,      # Grassland
                            'farmland': 40, 'orchard': 40,      # Cropland
                            'residential': 50, 'commercial': 50, # Built-up
                            'bare_rock': 60, 'sand': 60,        # Bare
                            'wetland': 90, 'marsh': 90          # Wetland
                        }
                        
                        for element in data.get('elements', []):
                            tags = element.get('tags', {})
                            land_type = tags.get('natural', tags.get('landuse', ''))
                            
                            if land_type in osm_to_worldcover:
                                return osm_to_worldcover[land_type]
                        
                        return 50  # Default to built-up if nothing found
            
        except Exception as e:
            self.get_logger().debug(f"OSM land cover proxy error: {e}")
            return None

    async def get_osm_land_use_risk(self, lat, lon):
        """Fallback vegetation risk from OSM land use"""
        # Simplified risk mapping
        risk_mapping = {
            'forest': 0.8, 'wood': 0.8,
            'scrub': 0.9, 'heath': 0.8,
            'grassland': 0.7, 'meadow': 0.6,
            'farmland': 0.4, 'orchard': 0.5,
            'residential': 0.2, 'commercial': 0.1
        }
        return 0.5  # Default medium risk

    async def get_global_infrastructure_risk(self, lat, lon):
        """Get infrastructure risk using global OSM data"""
        try:
            # Global infrastructure query using OSM
            overpass_query = f"""
            [out:json][timeout:15];
            (
              node["amenity"~"^(hospital|clinic|school|university|fire_station|police)$"](around:15000,{lat},{lon});
              way["amenity"~"^(hospital|clinic|school|university|fire_station|police)$"](around:15000,{lat},{lon});
              node["power"~"^(plant|substation|generator)$"](around:15000,{lat},{lon});
              way["power"~"^(plant|substation|generator)$"](around:15000,{lat},{lon});
              node["emergency"](around:15000,{lat},{lon});
              way["emergency"](around:15000,{lat},{lon});
            );
            out center;
            """
            
            async with aiohttp.ClientSession() as session:
                async with session.post(
                    self.api_config['overpass_base'],
                    data=overpass_query,
                    timeout=20
                ) as response:
                    if response.status == 200:
                        data = await response.json()
                        
                        max_risk = 0
                        for element in data.get('elements', []):
                            tags = element.get('tags', {})
                            element_lat = element.get('lat', element.get('center', {}).get('lat'))
                            element_lon = element.get('lon', element.get('center', {}).get('lon'))
                            
                            if not (element_lat and element_lon):
                                continue
                            
                            # Determine infrastructure priority
                            priority_weight = 0
                            for tag_key, tag_value in tags.items():
                                if tag_key == 'amenity' and tag_value in self.infrastructure_priorities:
                                    priority_weight = self.infrastructure_priorities[tag_value]
                                elif tag_key == 'power':
                                    priority_weight = self.infrastructure_priorities.get('power', 0.8)
                                elif tag_key == 'emergency':
                                    priority_weight = self.infrastructure_priorities.get('emergency', 1.0)
                            
                            if priority_weight > 0:
                                distance_km = self.haversine_distance(lat, lon, element_lat, element_lon)
                                
                                # Distance-based risk calculation
                                if distance_km < 2:
                                    risk = priority_weight
                                elif distance_km < 10:
                                    risk = priority_weight * (10 - distance_km) / 8
                                elif distance_km < 15:
                                    risk = priority_weight * 0.2 * (15 - distance_km) / 5
                                else:
                                    risk = 0
                                
                                max_risk = max(max_risk, risk)
                        
                        return max_risk
            
        except Exception as e:
            self.get_logger().debug(f"Global infrastructure error: {e}")
        
        return 0

    async def get_global_weather_modifier(self, lat, lon):
        """Get weather modifier using global weather API"""
        cache_key = f"{lat:.3f},{lon:.3f}"
        
        if cache_key in self.weather_cache:
            return self.weather_cache[cache_key]
        
        try:
            # OpenWeatherMap provides global coverage
            api_key = self.api_config['openweather_key']
            if api_key == 'YOUR_API_KEY_HERE':
                return 1.0  # No weather data available
            
            url = f"{self.api_config['openweather_base']}/weather"
            params = {
                'lat': lat,
                'lon': lon,
                'appid': api_key,
                'units': 'metric'
            }
            
            async with aiohttp.ClientSession() as session:
                async with session.get(url, params=params, timeout=10) as response:
                    if response.status == 200:
                        data = await response.json()
                        
                        temp = data['main']['temp']
                        humidity = data['main']['humidity']
                        wind_speed = data['wind']['speed']  # m/s
                        
                        modifier = 1.0
                        
                        # Temperature effect (higher = more risk)
                        if temp > 30:      # 30¬∞C+
                            modifier *= 1.4
                        elif temp > 25:    # 25-30¬∞C
                            modifier *= 1.2
                        elif temp < 5:     # Below 5¬∞C
                            modifier *= 0.6
                        
                        # Humidity effect (lower = more risk)
                        if humidity < 30:
                            modifier *= 1.5
                        elif humidity < 50:
                            modifier *= 1.2
                        elif humidity > 80:
                            modifier *= 0.7
                        
                        # Wind effect (higher = more risk)
                        if wind_speed > 8:     # >8 m/s
                            modifier *= 1.3
                        elif wind_speed > 5:   # 5-8 m/s
                            modifier *= 1.1
                        
                        self.weather_cache[cache_key] = modifier
                        return modifier
            
        except Exception as e:
            self.get_logger().debug(f"Global weather error: {e}")
        
        return 1.0  # No weather modifier

    def get_fire_intensity_score(self, fire_info):
        """Calculate fire intensity from fire characteristics"""
        confidence = fire_info.get('confidence', 70)
        brightness = fire_info.get('brightness', 300)
        
        intensity_score = (confidence / 100.0) * 0.7 + (min(brightness, 500) / 500.0) * 0.3
        return min(1.0, intensity_score)

    def _fallback_prioritize_fire(self, fire_id, fire_info):
        """Fallback prioritization when APIs fail"""
        # Simple fallback based on location
        priority_data = {
            'fire_id': fire_id,
            'priority_level': 3,
            'priority_name': "MEDIUM",
            'priority_score': 50.0,
            'factors': {
                'population_risk': 0.3,
                'vegetation_risk': 0.5,
                'infrastructure_risk': 0.2,
                'fire_intensity': self.get_fire_intensity_score(fire_info)
            },
            'location': fire_info['location'],
            'gps_coords': self.local_to_gps(fire_info['location'][0], fire_info['location'][1]),
            'timestamp': datetime.now().isoformat(),
            'fallback': True
        }
        
        self.prioritized_fires[fire_id] = priority_data
        self.get_logger().warn(f"‚ö†Ô∏è {fire_id} priority: MEDIUM (fallback mode)")
        self.publish_priority_status()

    def process_fire_assignments(self):
        """Assign fires to drones based on priority"""
        unassigned_fires = [
            (fire_id, priority_data) for fire_id, priority_data in self.prioritized_fires.items()
            if fire_id not in self.assigned_fires and fire_id not in self.completed_fires
        ]
        
        if not unassigned_fires:
            return
        
        # Sort by priority
        unassigned_fires.sort(key=lambda x: (x[1]['priority_level'], -x[1]['priority_score']))
        
        # Find available drones
        available_drones = [
            drone for drone in self.available_drones
            if drone not in self.drone_assignments
        ]
        
        # Assign highest priority fires
        for fire_id, priority_data in unassigned_fires:
            if not available_drones:
                break
            
            drone_id = available_drones.pop(0)
            
            assignment = {
                'task_id': fire_id,
                'drone_id': drone_id,
                'location': priority_data['location'],
                'priority': priority_data['priority_level'],
                'priority_name': priority_data['priority_name'],
                'priority_score': priority_data['priority_score'],
                'priority_factors': priority_data['factors']
            }
            
            self.assignments_pub.publish(String(data=json.dumps(assignment)))
            self.assigned_fires.add(fire_id)
            self.drone_assignments[drone_id] = fire_id
            
            self.get_logger().info(
                f"üéØ Assigned {fire_id} ({priority_data['priority_name']}) to {drone_id}"
            )

    def publish_priority_status(self):
        """Publish fire priority status"""
        status_data = {
            'timestamp': datetime.now().isoformat(),
            'total_fires': len(self.prioritized_fires),
            'fires_by_priority': {},
            'assignment_summary': {
                'assigned': len(self.assigned_fires),
                'completed': len(self.completed_fires),
                'pending': len(self.prioritized_fires) - len(self.assigned_fires) - len(self.completed_fires)
            }
        }
        
        # Group by priority level
        for priority_level in range(1, 6):
            fires_at_level = [
                f for f in self.prioritized_fires.values()
                if f['priority_level'] == priority_level
            ]
            status_data['fires_by_priority'][priority_level] = len(fires_at_level)
        
        self.priority_status_pub.publish(String(data=json.dumps(status_data)))

    def task_done_callback(self, msg):
        """Handle task completion"""
        try:
            data = json.loads(msg.data)
            task_id = data['task_id']
            drone_id = data['drone_id']
            
            self.completed_fires.add(task_id)
            if drone_id in self.drone_assignments:
                del self.drone_assignments[drone_id]
            
            if task_id in self.prioritized_fires:
                priority_info = self.prioritized_fires[task_id]
                self.get_logger().info(
                    f"‚úÖ {priority_info['priority_name']} priority fire {task_id} "
                    f"extinguished by {drone_id}"
                )
            
        except Exception as e:
            self.get_logger().error(f"Error processing task completion: {e}")

    def haversine_distance(self, lat1, lon1, lat2, lon2):
        """Calculate distance between GPS coordinates"""
        R = 6371  # Earth radius in km
        dlat = math.radians(lat2 - lat1)
        dlon = math.radians(lon2 - lon1)
        a = (math.sin(dlat/2)**2 + 
             math.cos(math.radians(lat1)) * math.cos(math.radians(lat2)) * 
             math.sin(dlon/2)**2)
        c = 2 * math.asin(math.sqrt(a))
        return R * c

    def local_to_gps(self, x, y):
        """Convert local coordinates to GPS"""
        lat = self.sim_center_lat + (y / 110540)
        lon = self.sim_center_lon + (x / (111320 * math.cos(math.radians(lat))))
        return lat, lon

def main(args=None):
    rclpy.init(args=args)
    
    # Initialize async event loop
    import threading
    import asyncio
    
    def start_async_loop():
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        loop.run_forever()
    
    async_thread = threading.Thread(target=start_async_loop, daemon=True)
    async_thread.start()
    
    node = GlobalFirePrioritizationManager()
    
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()

# GLOBAL COVERAGE SUMMARY:
"""
üåç WORLDWIDE DATA SOURCES:

‚úÖ FULLY GLOBAL (FREE):
- OpenStreetMap: Global infrastructure, population places, land use
- WorldPop: Global population density data
- OpenWeatherMap: Global weather (free API key required)
- ESA WorldCover: Global 10m land cover (access via Copernicus)

üìä RECOMMENDED GLOBAL SETUP:

For ANY location worldwide:
1. Population: WorldPop + OSM populated places
2. Vegetation: ESA WorldCover + OSM land use fallback  
3. Infrastructure: OpenStreetMap (global coverage)
4. Weather: OpenWeatherMap (get free API key)

SETUP INSTRUCTIONS:
1. Get free OpenWeatherMap API key: https://openweathermap.org/api
2. Update your coordinates:
   self.sim_center_lat = YOUR_LATITUDE
   self.sim_center_lon = YOUR_LONGITUDE
3. Install: pip install aiohttp requests numpy rclpy

TESTED REGIONS:
‚úÖ North America (USA/Canada)
‚úÖ Europe  
‚úÖ Australia
‚úÖ Most of Asia
‚úÖ Parts of Africa and South America


"""
